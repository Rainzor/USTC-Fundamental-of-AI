# 前言

局部搜索算法简介
 ​ 局部搜索算法是一类可以有效解决优化问题的通用算法。它的基本原理是在临近解中迭代，使目标函数逐步优化，直至不能再优化为止。

 局部搜索算法可以这样描述：假设问题的解空间表示为S， 局部搜索算法从一个初始解i∈S  开始，然后根据具体问题定义的具体邻域结构，在当前解 i 的邻域 Si 内按一定规则找到一个新解，再用这个新解取代 i  成为当前解，判断是否满足算法结束条件，如果不满足再对当前解继续使用算法，如果满足则算法结束，当前解就作为算法的最终解。

局部搜索算法具有以下特点：

算法结构通用易实现。只要定义好具体问题相关的邻域，就能有效的求解该问题。
 算法性能和邻域的定义以及初始状态有关。邻域定义的不同或初始状态选取的不同会对算法的性能产生决定性的影响。
 算法的局部优化特性。算法容易陷入局部最优解，达到全局最优比较困难。
 局部搜索算法主要包含五大要素：

目标函数：用来判断解的优劣。
 邻域的定义：根据不同问题，有着不同的邻域定义。
 初始解的产生规则
 新解的产生和接受规则
 算法终止准则（常见的三个准则:求解时间；迭代次数；和解质量提高比例）

------

以下为局部搜索的有关算法：

# 一、局部搜索算法（local search）

局部搜索是解决最优化问题的一种启发式算法。对于某些计算起来非常复杂的最优化问题，比如各种NP完全问题，要找到最优解需要的时间随问题规模呈指数增长，因此诞生了各种启发式算法来退而求其次寻找次优解，是一种近似算法（Approximate algorithms），以时间换精度的思想。局部搜索就是其中的一种方法。

局部搜索算法是从爬山法改进而来的。
 简单来说，局部搜索算法是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。

在计算机科学中，局部搜索是解决最优化问题的一种启发式算法。局部搜索从一个初始解出发，然后搜索解的邻域，如有更优的解则移动至该解并继续执行搜索，否则返回当前解。

局部搜索算法的基本思想：在搜索过程中，始终选择当前点的邻居中与离目标最近者的方向搜索。　
 　
 局部搜索的优点：简单、灵活及易于实现，缺点是容易陷入局部最优且解的质量与初始解和邻域的结构密切相关。

# 二、 爬山法（HILL-CLIMBING）

爬山算法：爬山算法是一种简单的贪心搜索算法，该算法每次从当前位置的临近空间中选择一个最优解作为当前解，直到达到一个局部最优解。

爬山算法的输入是定义的两个局部变量，一个是当前状态（当前结点），还有一个就是用来存储邻居结点的neighbor。我们从初始结点（也就是我们的当前结点）出发，开始往前爬山（往前搜索）。首先根据当前结点能够产生多少个后续结点，然后在这些后续结点中选择一个最大值（这个值是用你所定义的评估函数评估出来的）的后续结点，并将它放进neighbor中，然后将后续结点的值与当前结点的值进行比较，如果发现当前结点的值比后续结点的值要大，那么就意味着当前结点就是一个局部最值点了，所以就不用动了，把当前结点对应的状态返回即可。但是如果当前结点的值比后续结点的值要小，那么就往前走。这样一步一步地进行迭代，直到走到一个局部最值点。

**我们可以类比成一个兔子爬山的例子，为了找出地球上最高的山，一群有志气的兔子们开始想办法。**

爬山算法可以类比成一个有失忆的兔子在浓雾中爬山。这里就揭示了爬山算法的两个问题：

**失忆**：就是说这只兔子不记得他去过什么地方，它只记得他现在所处的位置，以及周边的情况（因为有浓雾，所以它只能看到最近的周边的情况）。

所以说他在任何时候只存储一个当前的状态，之前的所有的状态全部不记得了。那么我们就可以看出爬山算法非常依赖于这个初始状态（如果初始状态距离全局最值点很近的话，是更容易搜索到全局最值点的）。

**浓雾**：当他走到一个局部最值点时，因为他看见远处是否还有更大的最值点，所以就把当前这个局部最值点返回给你（爬山算法的返回是返回一个状态而不是一个路径，这个状态就是一个局部最值点）。

所以说，爬山算法的主要缺点是可能会陷入局部最优解，而不一定能搜索到全局最优解。

## 模拟退火（SIMULATED ANNEALING）

为了防止陷入局部最优，模拟退火算法以一定概率接受比当前解差的解，接受差解的概率随着迭代次数的增加而下降，或者说是随着温度T的下降而下降。

该算法从一个初始解开始，这个初始解可以是随机选择的，也可以是启发式方式得到的，并初始化一个温度。在每次迭代过程中，从当前解的邻居解中随机的选择一个解，若随机选择的一个邻居解比当前解的质量好，则替换当前解，若质量比当前解差，则以一定的概率接受这个差解，来替换当前解。最后更新温度T，进行下一次迭代。

**同样类比成兔子爬山，模拟退火方法是一群喝醉的兔子。**
 兔子喝醉了。他随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，他渐渐清醒了并朝最高方向跳去。这就是模拟退火。

## 集束搜索（Beam Search）

1.简介

Beam  Search（集束搜索）是一种启发式图搜索算法，通常用在图的解空间比较大的情况下，为了减少搜索所占用的空间和时间，在每一步深度扩展的时候，剪掉一些质量比较差的结点，保留下一些质量较高的结点。这样减少了空间消耗，并提高了时间效率，但缺点就是有可能存在潜在的最佳方案被丢弃，因此Beam Search算法是不完全的，一般用于解空间较大的系统中。

2.流程

Beam Search（集束搜索）使用广度优先策略建立搜索树，在树的每一层，按照启发代价对节点进行排序，然后仅留下预先确定的个数（Beam Width-集束宽度）的节点，仅这些节点在下一层次继续扩展，其他节点就被剪掉了。如果集束宽度无穷大，那该搜索就是宽度优先搜索。

集束宽度可以是预先定好的，也可以是变动的，可以先按照一个最小的集束宽度进行搜索，如果没有找到合适的解，再扩大集束宽度再找一遍。

Ps.  个人认为集束搜索方法其实提供了一种找最优解的思路，就是说在适当的情况下，可以剪掉一些可信度低的路径，在实际使用中，可以每一层的集束宽度不一致，比如在初始的一些层次中多保留一些结果，在后边就可以放心大胆的进行剪枝。当然也可以活学活用，可以结合深度优先算法，通过回溯，可以找到最优解。

3.应用

Beam Search（集束搜索）多用在一些大型系统中，比如机器翻译系统，语音识别系统等，因为这些系统中的数据集可能非常大，而且结果也没有唯一正确的解，系统用最快的方式找到最接近正确的解才是系统的目标。

## [遗传算法](https://so.csdn.net/so/search?q=遗传算法&spm=1001.2101.3001.7020)（Genetic algorithm）

遗传算法实际上是随机束搜索的变形, 通过吧两个父状态结合生成后继。

种群：种群中的每个个体都是潜在解
 个体表示： 染色体， 实际就是状态的表示
 适应度函数：表示解的好坏程度
 选择（利用）：根据适应度选取比较好的解优先进行两两繁殖
 交叉（利用为主+探索）： 选取一个杂交点， 两边染色体互相交换
 变异（探索）：每个位置都会小概率发生变异

**类比成兔子，遗传算法是一群吃了失忆药片随机分布在地球上的某些地方的兔子们**。
 他们不知道自己的使命是什么。但是，如果你过几年就杀死一部分海拔低的兔子，多产的兔子们自己就会找到珠穆朗玛峰。这就是遗传算法。

------

